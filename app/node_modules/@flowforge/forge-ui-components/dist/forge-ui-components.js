'use strict';

var marked = require('marked');
var vue = require('vue');
var solid = require('@heroicons/vue/solid');
var outline = require('@heroicons/vue/outline');

const instances = new Map();

/**
 * Adds a `v-click-outside` directive that can be used to trigger a callback when
 * the user clicks outside of the element.
 *
 * Used by Dropdown to close its menu when the user clicks out
 */

const directive$1 = {
    name: 'click-outside',
    mounted (element, options) {
        const handler = function (evt) {
            if (!evt.target !== element && !element.contains(evt.target)) {
                return options.value()
            } else {
                return null
            }
        };
        document.addEventListener('click', handler, true);
        instances.set(element, handler);
    },
    unmounted (element) {
        const handler = instances.get(element);
        if (handler) {
            document.removeEventListener('click', handler, true);
        }
        instances.delete(element);
    }
};

function renderTooltip (el, binding, vnode) {
    el.classList.add('ff-tooltip-container');

    let posClass = 'ff-tooltip-right';
    if (binding.arg) {
        posClass = 'ff-tooltip-' + binding.arg;
    }

    const span = document.createElement('span');
    span.className = `ff-tooltip ${posClass}`;
    span.innerHTML = binding.value;

    el.appendChild(span);
}

const directive = {
    name: 'ff-tooltip',
    mounted: (el, binding) => {
        if (el && binding && binding.value) {
            renderTooltip(el, binding);
        }
    },
    updated (el, binding) {
        if (binding.value) {
            const tooltips = el.getElementsByClassName('ff-tooltip');
            if (tooltips.length) {
                // update existing tooltip
                tooltips[0].innerHTML = binding.value;
            } else {
                // render a new tooltip
                renderTooltip(el, binding);
            }
        } else {
            // remove all tooltips
            const tooltips = el.getElementsByClassName('ff-tooltip');
            for (let i = 0; i < tooltips.length; i++) {
                tooltips[i].remove();
            }
        }
    }
};

var directives = {
    FFClickOutside: directive$1,
    FFTooltip: directive
};

var script$l = {
    name: 'ff-button',
    props: {
        type: {
            default: 'button', // "button" or "submit"
            type: String
        },
        kind: {
            default: 'primary',
            type: String // "primary", "secondary", "tertiary"
        },
        size: {
            default: 'normal',
            type: String // "small", "normal", "full-width"
        },
        to: {
            default: null,
            type: [String, Object]
        }
    },
    computed: {
        hasIcon: function () {
            return this.$slots['icon-left'] || this.$slots['icon-right'] || this.$slots.icon
        },
        hasIconLeft: function () {
            return this.$slots['icon-left']
        },
        hasIconRight: function () {
            return this.$slots['icon-right']
        },
        isIconOnly: function () {
            return this.$slots.icon
        }
    },
    methods: {
        go: function () {
            if (this.to) {
                this.$router.push(this.to);
            }
        },
        focus () {
            this.$refs.input?.focus();
        },
        blur () {
            this.$refs.input?.blur();
        }
    }
};

const _hoisted_1$g = ["type"];
const _hoisted_2$9 = {
  key: 0,
  class: "ff-btn--icon ff-btn--icon-left"
};
const _hoisted_3$7 = {
  key: 1,
  class: "ff-btn--icon"
};
const _hoisted_4$5 = {
  key: 2,
  class: "ff-btn--icon ff-btn--icon-right"
};

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("button", {
    ref: "input",
    class: vue.normalizeClass(["ff-btn transition-fade--color", 'ff-btn--' + $props.kind + ($options.hasIcon ? ' ff-btn-icon' : '') + ($props.size === 'small' ? ' ff-btn-small' : '') + ($props.size === 'full-width' ? ' ff-btn-fwidth' : '')]),
    type: $props.type,
    onClick: _cache[0] || (_cache[0] = $event => ($options.go()))
  }, [
    ($options.hasIconLeft)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$9, [
          vue.renderSlot(_ctx.$slots, "icon-left")
        ]))
      : vue.createCommentVNode("v-if", true),
    ($options.isIconOnly)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3$7, [
          vue.renderSlot(_ctx.$slots, "icon")
        ]))
      : vue.createCommentVNode("v-if", true),
    vue.renderSlot(_ctx.$slots, "default"),
    ($options.hasIconRight)
      ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$5, [
          vue.renderSlot(_ctx.$slots, "icon-right")
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, _hoisted_1$g))
}

script$l.render = render$k;
script$l.__file = "src/components/Button.vue";

var script$k = {
    name: 'ff-kebab-menu',
    components: {
        DotsVerticalIcon: solid.DotsVerticalIcon
    },
    props: {
        // eslint-disable-next-line vue/prop-name-casing
        'menu-align': {
            type: String,
            default: 'right'
        }
    },
    data () {
        return {
            open: false
        }
    },
    methods: {
        openOptions () {
            this.open = !this.open;
        },
        closeOptions () {
            this.open = false;
        }
    }
};

function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DotsVerticalIcon = vue.resolveComponent("DotsVerticalIcon");
  const _directive_click_outside = vue.resolveDirective("click-outside");

  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["ff-kebab-menu", {'active': $data.open}])
  }, [
    vue.createCommentVNode(" using this v-if hack in order to enable both\n        the button and click-outside to work when closing the menu "),
    (!$data.open)
      ? (vue.openBlock(), vue.createBlock(_component_DotsVerticalIcon, {
          key: 0,
          onClick: _cache[0] || (_cache[0] = vue.withModifiers($event => ($options.openOptions()), ["stop"]))
        }))
      : vue.createCommentVNode("v-if", true),
    ($data.open)
      ? (vue.openBlock(), vue.createBlock(_component_DotsVerticalIcon, {
          key: 1,
          onClick: _cache[1] || (_cache[1] = vue.withModifiers($event => ($options.closeOptions()), ["stop"]))
        }))
      : vue.createCommentVNode("v-if", true),
    ($data.open)
      ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("ul", {
          key: 2,
          class: vue.normalizeClass(["ff-kebab-options", 'ff-kebab-options--' + _ctx.menuAlign])
        }, [
          vue.renderSlot(_ctx.$slots, "default")
        ], 2 /* CLASS */)), [
          [_directive_click_outside, $options.closeOptions]
        ])
      : vue.createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$k.render = render$j;
script$k.__file = "src/components/KebabMenu.vue";

function searchObjectProps (object, searchTerm, searchProps = []) {
    const searchPropsMap = searchProps
        .map((prop) => {
            const [first, ...rest] = prop.split('.');

            return [first, rest.join('.')]
        })
        .reduce((map, [propName, subProp]) => {
            if (!map.has(propName)) {
                map.set(propName, [subProp]);
            } else {
                map.get(propName).push(subProp);
            }

            return map
        }, new Map());

    return Object.entries(object).some(([propName, propValue]) => {
        // Skip props that aren't being considered
        if (searchPropsMap?.size > 0 && !searchPropsMap.has(propName)) {
            return false
        }

        // Skip null, undefined, or empty props (inc arrays) since they'll never match
        if (propValue === null || propValue === undefined || propValue.length === 0) {
            return false
        }

        // Search recursively inside of objects
        if (typeof propValue === 'object') {
            return searchObjectProps(propValue, searchTerm, searchPropsMap.get(propName))
        }

        // Skip non numeric strings (bool, undefined, null, etc)
        if (typeof propValue === 'number') {
            propValue = propValue.toString();
        }
        if (typeof propValue !== 'string') {
            return false
        }

        return propValue.toLowerCase().includes(searchTerm)
    })
}

var script$j = {
    name: 'ff-data-table',
    components: {
        SearchIcon: outline.SearchIcon,
        SwitchVerticalIcon: outline.SwitchVerticalIcon,
        SortAscendingIcon: outline.SortAscendingIcon,
        SortDescendingIcon: outline.SortDescendingIcon
    },
    props: {
        columns: {
            type: Array,
            default: () => []
        },
        rows: {
            type: Array,
            default: () => []
        },
        rowsSelectable: {
            type: Boolean,
            default: false
        },
        showSearch: {
            type: Boolean,
            default: false
        },
        searchPlaceholder: {
            type: String,
            default: null
        },
        search: {
            type: String,
            default: null
        },
        searchFields: {
            type: Array,
            default: () => []
        },
        showLoadMore: {
            type: Boolean,
            default: false
        },
        loading: {
            type: Boolean,
            default: false
        },
        loadingMessage: {
            type: String,
            default: 'Loading Data...'
        },
        noDataMessage: {
            type: String,
            default: 'No Data Found'
        }
    },
    emits: ['update:search', 'load-more', 'row-selected'],
    data () {
        return {
            internalSearch: '',
            sort: {
                highlightColumn: null,
                key: '',
                order: 'desc'
            },
            pagination: {
                active: -1,
                max: -1
            },
            orders: ['desc', 'asc']
        }
    },
    computed: {
        showOptions: function () {
            return this.showSearch || this.$slots.actions
        },
        filterTerm: {
            get () {
                return this.search
            },
            set (value) {
                this.internalSearch = value;
                this.$emit('update:search', value);
            }
        },
        hasContextMenu: function () {
            return this.$slots['context-menu']
        },
        messageColSpan: function () {
            return this.hasContextMenu ? this.columns.length + 1 : this.columns.length
        },
        filteredRows: function () {
            const rows = this.filterRows([...this.rows]);
            if (this.sort.key) {
                return rows.sort((a, b) => {
                    // Catch undefined and null, swapping to ''
                    const aProp = this.lookupProperty(a, this.sort.key) ?? '';
                    const bProp = this.lookupProperty(b, this.sort.key) ?? '';

                    const collator = new Intl.Collator(undefined, {
                        numeric: true,
                        sensitivity: 'base'
                    });

                    // Ordering
                    const [aValue, bValue] =
                        this.sort.order === 'asc'
                            ? [aProp, bProp]
                            : [bProp, aProp];

                    // Booleans are grouped together, sorted as booleans, not strings
                    if (
                        typeof aValue === 'boolean' &&
                        typeof bValue === 'boolean'
                    ) {
                        return aValue === bValue ? 0 : (aValue > bValue ? 1 : -1)
                    } else if (
                        typeof aValue === 'boolean' ||
                        typeof bValue === 'boolean'
                    ) {
                        return this.sort.order === 'asc' ? -1 : 1
                    }

                    return collator.compare(aValue, bValue)
                })
            } else {
                return rows
            }
        }
    },
    methods: {
        filterRows (rows) {
            const search = this.internalSearch;
            if (!search) {
                return rows
            }

            return rows.filter((row) => {
                return searchObjectProps(row, search.toLowerCase(), this.searchFields)
            })
        },
        rowClick (row) {
            if (this.rowsSelectable) {
                this.$emit('row-selected', row);
            }
        },
        sortBy (col, colIndex) {
            if (col.sortable) {
                if (this.sort.key === col.key) {
                    this.cycleOrder();
                } else {
                    this.sort.key = col.key;
                    this.resetOrder();
                }
                if (this.sort.key) {
                    this.sort.highlightColumn = colIndex;
                } else {
                    this.sort.highlightColumn = null;
                }
            }
        },
        cycleOrder () {
            if (this.sort.order === 'desc') {
                this.sort.order = 'asc';
            } else {
                this.sort.key = null;
                this.sort.order = 'desc';
            }
        },
        resetOrder () {
            this.sort.order = this.orders[0];
        },
        lookupProperty (obj, property) {
            const parts = property.split('.');
            if (parts.length === 1) {
                return obj[property]
            } else {
                while (parts.length > 0) {
                    const part = parts.shift();
                    if (Object.hasOwn(obj, part)) {
                        obj = obj[part];
                    } else {
                        return undefined
                    }
                }
            }
            return obj
        }
    }
};

const _hoisted_1$f = { class: "ff-data-table" };
const _hoisted_2$8 = {
  key: 0,
  class: "ff-data-table--options"
};
const _hoisted_3$6 = {
  key: 1,
  class: "ff-data-table--actions"
};
const _hoisted_4$4 = { class: "ff-data-table--data" };
const _hoisted_5$1 = {
  key: 1,
  class: "ff-loadmore"
};

function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SearchIcon = vue.resolveComponent("SearchIcon");
  const _component_ff_text_input = vue.resolveComponent("ff-text-input");
  const _component_SwitchVerticalIcon = vue.resolveComponent("SwitchVerticalIcon");
  const _component_SortAscendingIcon = vue.resolveComponent("SortAscendingIcon");
  const _component_SortDescendingIcon = vue.resolveComponent("SortDescendingIcon");
  const _component_ff_data_table_cell = vue.resolveComponent("ff-data-table-cell");
  const _component_ff_data_table_row = vue.resolveComponent("ff-data-table-row");

  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$f, [
    ($options.showOptions)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$8, [
          ($props.showSearch)
            ? (vue.openBlock(), vue.createBlock(_component_ff_text_input, {
                key: 0,
                modelValue: $options.filterTerm,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.filterTerm) = $event)),
                class: "ff-data-table--search",
                "data-form": "search",
                placeholder: $props.searchPlaceholder
              }, {
                icon: vue.withCtx(() => [
                  vue.createVNode(_component_SearchIcon)
                ]),
                _: 1 /* STABLE */
              }, 8 /* PROPS */, ["modelValue", "placeholder"]))
            : vue.createCommentVNode("v-if", true),
          (_ctx.$slots.actions)
            ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$6, [
                vue.renderSlot(_ctx.$slots, "actions")
              ]))
            : vue.createCommentVNode("v-if", true)
        ]))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("table", _hoisted_4$4, [
      vue.renderSlot(_ctx.$slots, "table", {}, () => [
        vue.createElementVNode("thead", null, [
          vue.createCommentVNode(" HEADERS "),
          vue.renderSlot(_ctx.$slots, "header", {}, () => [
            vue.createVNode(_component_ff_data_table_row, null, {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($props.columns, (col, $index) => {
                  return (vue.openBlock(), vue.createBlock(_component_ff_data_table_cell, {
                    key: $index,
                    class: vue.normalizeClass([$data.sort.key === col.key ? 'sorted' : '', col.sortable ? 'sortable' : ''].concat(col.class)),
                    style: vue.normalizeStyle(col.style),
                    onClick: $event => ($options.sortBy(col, $index))
                  }, {
                    default: vue.withCtx(() => [
                      vue.createCommentVNode(" Internal div required to have flex w/sorting icons "),
                      vue.createElementVNode("div", null, [
                        vue.createTextVNode(vue.toDisplayString(col.label) + " ", 1 /* TEXT */),
                        (col.sortable && col.key !== $data.sort.key)
                          ? (vue.openBlock(), vue.createBlock(_component_SwitchVerticalIcon, {
                              key: 0,
                              class: "ff-icon ff-icon-sm"
                            }))
                          : vue.createCommentVNode("v-if", true),
                        (col.sortable && col.key === $data.sort.key && $data.sort.order === 'asc')
                          ? (vue.openBlock(), vue.createBlock(_component_SortAscendingIcon, {
                              key: 1,
                              class: "ff-icon ff-icon-sm icon-sorted"
                            }))
                          : vue.createCommentVNode("v-if", true),
                        (col.sortable && col.key === $data.sort.key && $data.sort.order === 'desc')
                          ? (vue.openBlock(), vue.createBlock(_component_SortDescendingIcon, {
                              key: 2,
                              class: "ff-icon ff-icon-sm icon-sorted"
                            }))
                          : vue.createCommentVNode("v-if", true)
                      ])
                    ]),
                    _: 2 /* DYNAMIC */
                  }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["class", "style", "onClick"]))
                }), 128 /* KEYED_FRAGMENT */)),
                ($options.hasContextMenu)
                  ? (vue.openBlock(), vue.createBlock(_component_ff_data_table_cell, { key: 0 }))
                  : vue.createCommentVNode("v-if", true)
              ]),
              _: 1 /* STABLE */
            })
          ])
        ]),
        vue.createElementVNode("tbody", null, [
          vue.createCommentVNode(" ROWS "),
          vue.renderSlot(_ctx.$slots, "rows", {}, () => [
            ($props.loading)
              ? (vue.openBlock(), vue.createBlock(_component_ff_data_table_row, { key: 0 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_ff_data_table_cell, {
                      class: "status-message",
                      colspan: $options.messageColSpan
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode(vue.toDisplayString($props.loadingMessage), 1 /* TEXT */)
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["colspan"])
                  ]),
                  _: 1 /* STABLE */
                }))
              : vue.createCommentVNode("v-if", true),
            (!$props.loading)
              ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList($options.filteredRows, (r, $index) => {
                  return (vue.openBlock(), vue.createBlock(_component_ff_data_table_row, {
                    key: $index,
                    data: r,
                    columns: $props.columns,
                    selectable: $props.rowsSelectable,
                    "highlight-cell": $data.sort.highlightColumn,
                    onSelected: $event => ($options.rowClick(r))
                  }, vue.createSlots({ _: 2 /* DYNAMIC */ }, [
                    ($options.hasContextMenu)
                      ? {
                          name: "context-menu",
                          fn: vue.withCtx(({row}) => [
                            vue.renderSlot(_ctx.$slots, "context-menu", { row: row })
                          ]),
                          key: "0"
                        }
                      : undefined
                  ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["data", "columns", "selectable", "highlight-cell", "onSelected"]))
                }), 128 /* KEYED_FRAGMENT */))
              : vue.createCommentVNode("v-if", true),
            (!$props.loading && $props.rows?.length > 0 && $options.filteredRows?.length === 0)
              ? (vue.openBlock(), vue.createBlock(_component_ff_data_table_row, { key: 2 }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(_component_ff_data_table_cell, {
                      class: "status-message",
                      colspan: $options.messageColSpan
                    }, {
                      default: vue.withCtx(() => [
                        vue.createTextVNode("No Data Found. Try Another Search.")
                      ]),
                      _: 1 /* STABLE */
                    }, 8 /* PROPS */, ["colspan"])
                  ]),
                  _: 1 /* STABLE */
                }))
              : (!$props.loading && $options.filteredRows?.length === 0)
                ? (vue.openBlock(), vue.createBlock(_component_ff_data_table_row, { key: 3 }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(_component_ff_data_table_cell, {
                        class: "status-message",
                        colspan: $options.messageColSpan
                      }, {
                        default: vue.withCtx(() => [
                          vue.createTextVNode(vue.toDisplayString($props.noDataMessage), 1 /* TEXT */)
                        ]),
                        _: 1 /* STABLE */
                      }, 8 /* PROPS */, ["colspan"])
                    ]),
                    _: 1 /* STABLE */
                  }))
                : vue.createCommentVNode("v-if", true)
          ])
        ])
      ])
    ]),
    ($props.showLoadMore)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5$1, [
          vue.createElementVNode("span", {
            "data-action": "load-more",
            onClick: _cache[1] || (_cache[1] = $event => (_ctx.$emit('load-more')))
          }, "Load More...")
        ]))
      : vue.createCommentVNode("v-if", true)
  ]))
}

script$j.render = render$i;
script$j.__file = "src/components/data-table/DataTable.vue";

var script$i = {
    name: 'ff-data-table-row',
    props: {
        columns: {
            type: Array,
            default: null
        },
        data: {
            type: Object,
            default: null
        },
        selectable: {
            type: Boolean,
            default: false
        },
        highlightCell: {
            type: Number,
            default: null
        }
    },
    emits: ['selected'],
    computed: {
        hasContextMenu: function () {
            return this.$slots['context-menu']
        }
    },
    methods: {
        isBool: function (value) {
            return typeof (value) === 'boolean'
        },
        getCellData: function (data, col) {
            if (col.component?.map) {
                // create a clone of data in case we override existing properties
                // this is okay, as long as it's contained within a cell.
                // e.g. a component may look for an "id" re: a user, but the whole row
                // may be linked to a template, which has it's own "id"
                const cell = Object.assign({}, data);
                // map the relevant properties in accordance to the provided map
                const dataMap = col.component?.map;
                for (const [to, from] of Object.entries(dataMap)) {
                    cell[to] = this.lookupProperty(cell, from);
                }
                return cell
            } else {
                return data
            }
        },
        lookupProperty (obj, property) {
            const parts = property.split('.');
            if (parts.length === 1) {
                return obj[property]
            } else {
                while (parts.length > 0) {
                    const part = parts.shift();
                    if (Object.hasOwn(obj, part)) {
                        obj = obj[part];
                    } else {
                        return undefined
                    }
                }
            }
            return obj
        }
    }
};

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ff_check = vue.resolveComponent("ff-check");
  const _component_ff_data_table_cell = vue.resolveComponent("ff-data-table-cell");
  const _component_ff_kebab_menu = vue.resolveComponent("ff-kebab-menu");

  return (vue.openBlock(), vue.createElementBlock("tr", {
    class: vue.normalizeClass(["ff-data-table--row", {'selectable': $props.selectable}])
  }, [
    vue.renderSlot(_ctx.$slots, "default", {}, () => [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($props.columns, (col, $column) => {
        return (vue.openBlock(), vue.createBlock(_component_ff_data_table_cell, {
          key: col.label,
          class: vue.normalizeClass(col.class),
          style: vue.normalizeStyle(col.style),
          highlight: $props.highlightCell === $column,
          onClick: _cache[0] || (_cache[0] = $event => (_ctx.$emit('selected', $props.data)))
        }, {
          default: vue.withCtx(() => [
            (col.component)
              ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(col.component.is), vue.normalizeProps(vue.mergeProps({ key: 0 }, {...col.component.extraProps ?? {}, ...$options.getCellData($props.data, col)})), null, 16 /* FULL_PROPS */))
              : (!$options.isBool($options.lookupProperty($props.data, col.key)))
                ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 1 }, [
                    vue.createTextVNode(vue.toDisplayString($options.lookupProperty($props.data, col.key)), 1 /* TEXT */)
                  ], 64 /* STABLE_FRAGMENT */))
                : (vue.openBlock(), vue.createBlock(_component_ff_check, {
                    key: 2,
                    value: $options.lookupProperty($props.data, col.key)
                  }, null, 8 /* PROPS */, ["value"]))
          ]),
          _: 2 /* DYNAMIC */
        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["class", "style", "highlight"]))
      }), 128 /* KEYED_FRAGMENT */))
    ]),
    ($options.hasContextMenu)
      ? (vue.openBlock(), vue.createBlock(_component_ff_data_table_cell, {
          key: 0,
          style: {"width":"50px"},
          onClick: _cache[1] || (_cache[1] = $event => (_ctx.$refs.kebab.openOptions()))
        }, {
          default: vue.withCtx(() => [
            vue.createVNode(_component_ff_kebab_menu, {
              ref: "kebab",
              "menu-align": "right"
            }, {
              default: vue.withCtx(() => [
                vue.renderSlot(_ctx.$slots, "context-menu", {
                  row: $props.data,
                  message: "hello world"
                })
              ]),
              _: 3 /* FORWARDED */
            }, 512 /* NEED_PATCH */)
          ]),
          _: 3 /* FORWARDED */
        }))
      : vue.createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$i.render = render$h;
script$i.__file = "src/components/data-table/DataTableRow.vue";

var script$h = {
    name: 'ff-data-table-cell',
    props: {
        colspan: {
            type: Number,
            default: 1
        },
        highlight: {
            type: Boolean,
            default: false
        }
    }
};

const _hoisted_1$e = ["colspan"];

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("td", {
    class: vue.normalizeClass(["ff-data-table--cell", {'highlight': $props.highlight}]),
    colspan: $props.colspan
  }, [
    vue.renderSlot(_ctx.$slots, "default")
  ], 10 /* CLASS, PROPS */, _hoisted_1$e))
}

script$h.render = render$g;
script$h.__file = "src/components/data-table/DataTableCell.vue";

var script$g = {
    name: 'ff-dialog',
    props: {
        header: {
            type: String,
            default: 'Dialog Box'
        },
        confirmLabel: {
            type: String,
            default: 'Confirm'
        },
        disablePrimary: {
            type: Boolean,
            default: false
        },
        kind: {
            type: String,
            default: 'primary'
        },
        closeOnConfirm: {
            type: Boolean,
            default: true
        }
    },
    emits: ['cancel', 'confirm'],
    data () {
        return {
            open: false
        }
    },
    watch: {
        open: function () {
            this.$refs.content.scrollTop = 0;
        }
    },
    methods: {
        show () {
            this.open = true;
        },
        close () {
            this.open = false;
        },
        cancel () {
            this.close();
            this.$emit('cancel');
        },
        confirm () {
            if (this.closeOnConfirm) {
                this.close();
            }
            this.$emit('confirm');
        }
    }
};

const _hoisted_1$d = { class: "ff-dialog-box" };
const _hoisted_2$7 = { class: "ff-dialog-header" };
const _hoisted_3$5 = {
  ref: "content",
  class: "ff-dialog-content"
};
const _hoisted_4$3 = { class: "ff-dialog-actions" };

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ff_button = vue.resolveComponent("ff-button");

  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["ff-dialog-container", 'ff-dialog-container--' + ($data.open ? 'open' : 'closed')])
  }, [
    vue.createElementVNode("div", _hoisted_1$d, [
      vue.createElementVNode("div", _hoisted_2$7, vue.toDisplayString($props.header), 1 /* TEXT */),
      vue.createElementVNode("div", _hoisted_3$5, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 512 /* NEED_PATCH */),
      vue.createElementVNode("div", _hoisted_4$3, [
        vue.renderSlot(_ctx.$slots, "actions", {}, () => [
          vue.createVNode(_component_ff_button, {
            kind: "secondary",
            onClick: _cache[0] || (_cache[0] = $event => ($options.cancel()))
          }, {
            default: vue.withCtx(() => [
              vue.createTextVNode("Cancel")
            ]),
            _: 1 /* STABLE */
          }),
          vue.createVNode(_component_ff_button, {
            kind: $props.kind,
            disabled: $props.disablePrimary,
            onClick: _cache[1] || (_cache[1] = $event => ($options.confirm()))
          }, {
            default: vue.withCtx(() => [
              vue.createTextVNode(vue.toDisplayString($props.confirmLabel), 1 /* TEXT */)
            ]),
            _: 1 /* STABLE */
          }, 8 /* PROPS */, ["kind", "disabled"])
        ])
      ])
    ])
  ], 2 /* CLASS */))
}

script$g.render = render$f;
script$g.__file = "src/components/DialogBox.vue";

var script$f = {
    name: 'ff-help',
    components: {
        QuestionMarkCircleIcon: solid.QuestionMarkCircleIcon
    },
    props: {
        text: {
            required: true,
            type: String
        },
        position: {
            default: 'right',
            type: String
        }
    }
};

const _hoisted_1$c = { class: "ff-help-tooltip ff-icon" };

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionMarkCircleIcon = vue.resolveComponent("QuestionMarkCircleIcon");
  const _directive_ff_tooltip = vue.resolveDirective("ff-tooltip");

  return vue.withDirectives((vue.openBlock(), vue.createElementBlock("span", _hoisted_1$c, [
    vue.createVNode(_component_QuestionMarkCircleIcon)
  ])), [
    [_directive_ff_tooltip, $props.text, $props.position]
  ])
}

script$f.render = render$e;
script$f.__file = "src/components/Help.vue";

var script$e = {
    name: 'ff-text-input',
    props: {
        // broker standard text-input props
        disabled: {
            type: Boolean,
            default: false
        },
        error: {
            type: String,
            default: ''
        },
        placeholder: {
            type: String,
            default: ''
        },
        // flowforge specific props
        size: {
            default: 'normal',
            type: String // "small", "normal"
        },
        type: {
            default: 'text', // One of: 'text', 'email', or 'password'
            type: String
        },
        // v-model
        modelValue: {
            type: String,
            default: ''
        }
    },
    emits: ['update:modelValue', 'input', 'blur', 'keyup', 'enter'],
    methods: {
        focus () {
            this.$refs.input?.focus();
        },
        blur () {
            this.$refs.input?.blur();
        }
    }
};

const _hoisted_1$b = ["type", "placeholder", "disabled", "value"];

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["ff-input ff-text-input", {'ff-input--error': $props.error}])
  }, [
    vue.renderSlot(_ctx.$slots, "icon"),
    vue.createElementVNode("input", {
      ref: "input",
      type: $props.type,
      placeholder: $props.placeholder,
      disabled: $props.disabled,
      value: $props.modelValue,
      onChange: _cache[0] || (_cache[0] = $event => (_ctx.$emit('update:modelValue', $event.target.value))),
      onInput: _cache[1] || (_cache[1] = $event => (_ctx.$emit('update:modelValue', $event.target.value))),
      onBlur: _cache[2] || (_cache[2] = $event => (_ctx.$emit('blur'))),
      onKeyup: _cache[3] || (_cache[3] = vue.withKeys($event => (_ctx.$emit('enter', _ctx.$evt)), ["enter"]))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_1$b)
  ], 2 /* CLASS */))
}

script$e.render = render$d;
script$e.__file = "src/components/form/TextInput.vue";

var script$d = {
    name: 'ff-dropdown',
    components: {
        ChevronDownIcon: solid.ChevronDownIcon
    },
    props: {
        modelValue: {
            default: null,
            type: [Number, String, Boolean, Object, Array]
        },
        placeholder: {
            default: 'Please Select',
            type: String
        },
        dropdownStyle: {
            default: 'select', // 'button' or 'select'
            type: String
        },
        optionsAlign: {
            default: 'left',
            type: String
        },
        disabled: {
            default: false,
            type: Boolean
        }
    },
    emits: ['update:modelValue'],
    data () {
        return {
            isOpen: false,
            selected: null,
            options: []
        }
    },
    computed: {
        value: {
            get () {
                return this.selected
            },
            set (selected) {
                this.selected = selected;
                this.$emit('update:modelValue', selected.value);
                this.isOpen = false;
            }
        }
    },
    watch: {
        modelValue: function () {
            // handle async setting of modelvalue where value is set after options have loaded
            this.checkOptions();
        }
    },
    methods: {
        focus () {
            this.$refs.dropdownLabel?.focus();
        },
        blur () {
            this.$refs.dropdownLabel?.blur();
        },
        open: function () {
            if (!this.disabled) {
                this.isOpen = !this.isOpen;
            }
        },
        close: function () {
            this.isOpen = false;
        },
        registerOption (option) {
            this.options.push(option);
            if (this.modelValue === option.value) {
                this.selected = option;
            }
        },
        checkOptions () {
            for (let i = 0; i < this.options.length; i++) {
                if (this.options[i].value === this.modelValue) {
                    this.selected = this.options[i];
                    return
                }
            }

            this.selected = null;
        }
    }
};

const _hoisted_1$a = ["disabled"];
const _hoisted_2$6 = { class: "ff-dropdown-selected-item" };

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronDownIcon = vue.resolveComponent("ChevronDownIcon");
  const _component_ff_button = vue.resolveComponent("ff-button");
  const _directive_click_outside = vue.resolveDirective("click-outside");

  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["ff-dropdown", 'ff-dropdown--' + ($data.isOpen ? 'open' : 'closed')]),
    disabled: $props.disabled
  }, [
    ($props.dropdownStyle === 'select')
      ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "dropdownLabel",
          class: "ff-dropdown-selected",
          tabindex: "0",
          onClick: _cache[0] || (_cache[0] = $event => ($options.open())),
          onKeydown: _cache[1] || (_cache[1] = vue.withKeys(vue.withModifiers($event => ($options.open()), ["prevent"]), ["space"]))
        }, [
          vue.renderSlot(_ctx.$slots, "placeholder", {}, () => [
            vue.createElementVNode("div", _hoisted_2$6, vue.toDisplayString($data.selected?.label || $props.placeholder), 1 /* TEXT */)
          ]),
          vue.createVNode(_component_ChevronDownIcon, { class: "ff-icon ff-btn--icon-right ff-dropdown-icon" })
        ], 544 /* HYDRATE_EVENTS, NEED_PATCH */))
      : ($props.dropdownStyle === 'button')
        ? (vue.openBlock(), vue.createBlock(_component_ff_button, {
            key: 1,
            onClick: _cache[2] || (_cache[2] = $event => ($options.open()))
          }, {
            "icon-right": vue.withCtx(() => [
              vue.createVNode(_component_ChevronDownIcon)
            ]),
            default: vue.withCtx(() => [
              vue.createTextVNode(vue.toDisplayString($props.placeholder) + " ", 1 /* TEXT */)
            ]),
            _: 1 /* STABLE */
          }))
        : vue.createCommentVNode("v-if", true),
    vue.withDirectives(vue.createElementVNode("div", null, [
      vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
        ref: "options",
        class: vue.normalizeClass(["ff-dropdown-options", {'ff-dropdown-options--full-width': $props.dropdownStyle === 'select', 'ff-dropdown-options--fit': $props.dropdownStyle === 'button', 'ff-dropdown-options--align-left': $props.optionsAlign === 'left', 'ff-dropdown-options--align-right': $props.optionsAlign === 'right'}])
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2 /* CLASS */)), [
        [_directive_click_outside, $options.close]
      ])
    ], 512 /* NEED_PATCH */), [
      [vue.vShow, $data.isOpen]
    ])
  ], 10 /* CLASS, PROPS */, _hoisted_1$a))
}

script$d.render = render$c;
script$d.__file = "src/components/form/Dropdown.vue";

var script$c = {
    name: 'ff-dropdown-option',
    props: {
        value: {
            default: null,
            type: [Number, String, Boolean, Array, Object]
        },
        label: {
            default: null,
            type: String
        }
    },
    mounted () {
        this.registerOption({
            value: this.value,
            label: this.label
        });
    },
    methods: {
        select () {
            this.$parent.value = {
                value: this.value,
                label: this.label
            };
        },
        registerOption (option) {
            this.$parent.registerOption(option);
        }
    }
};

function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", {
    class: "ff-dropdown-option",
    onClick: _cache[0] || (_cache[0] = $event => ($options.select()))
  }, [
    vue.renderSlot(_ctx.$slots, "default", {}, () => [
      vue.createTextVNode(vue.toDisplayString($props.label), 1 /* TEXT */)
    ])
  ]))
}

script$c.render = render$b;
script$c.__file = "src/components/form/DropdownOption.vue";

var script$b = {
    name: 'ff-checkbox',
    props: {
        label: {
            default: null,
            type: String
        },
        disabled: {
            default: false,
            type: Boolean
        },
        modelValue: {
            required: true,
            type: Boolean
        }
    },
    emits: ['update:modelValue'],
    computed: {
        model: {
            get () {
                return this.modelValue
            },
            set (value) {
                this.$emit('update:modelValue', value);
            }
        }
    },
    methods: {
        focus () {
            this.$refs.input?.focus();
        },
        blur () {
            this.$refs.input?.blur();
        },
        toggle () {
            if (!this.disabled) {
                this.model = !this.model;
            }
        }
    }

};

const _hoisted_1$9 = ["disabled"];
const _hoisted_2$5 = ["value", "disabled"];
const _hoisted_3$4 = ["checked"];

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("label", {
    class: "ff-checkbox",
    disabled: $props.disabled
  }, [
    vue.withDirectives(vue.createElementVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => (($options.model) = $event)),
      type: "checkbox",
      value: $props.modelValue,
      disabled: $props.disabled
    }, null, 8 /* PROPS */, _hoisted_2$5), [
      [vue.vModelCheckbox, $options.model]
    ]),
    vue.createElementVNode("span", {
      ref: "input",
      class: "checkbox",
      checked: $options.model,
      tabindex: "0",
      onKeydown: _cache[1] || (_cache[1] = vue.withKeys(vue.withModifiers((...args) => ($options.toggle && $options.toggle(...args)), ["prevent"]), ["space"]))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_3$4),
    ($props.label !== null || _ctx.$slots.default)
      ? (vue.openBlock(), vue.createElementBlock("label", {
          key: 0,
          onClick: _cache[2] || (_cache[2] = (...args) => ($options.toggle && $options.toggle(...args)))
        }, [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(vue.toDisplayString($props.label), 1 /* TEXT */)
          ])
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 8 /* PROPS */, _hoisted_1$9))
}

script$b.render = render$a;
script$b.__file = "src/components/form/Checkbox.vue";

var script$a = {
    name: 'ff-radio-group',
    props: {
        modelValue: {
            default: null,
            type: [String, Number]
        },
        label: {
            default: '',
            type: String
        },
        orientation: {
            default: 'horizontal',
            type: String
        },
        columns: {
            default: 2,
            type: Number
        },
        options: {
            default: null,
            type: Array
        }
    },
    emits: ['update:modelValue'],
    data: function () {
        return {
            internalOptions: this.options
        }
    },
    watch: {
        modelValue: function () {
            this.checkOptions();
        },
        internalOptions: function () {
            this.checkOptions();
        }
    },
    mounted () {
        this.checkOptions();
    },
    methods: {
        select: function (val) {
            this.$emit('update:modelValue', val);
        },
        checkOptions () {
            this.options.forEach((option, i) => {
                this.internalOptions[i].label = option.label;
                this.internalOptions[i].description = option.description;
                this.internalOptions[i].disabled = option.disabled;
                this.internalOptions[i].checked = (option.value === this.modelValue);
                if (this.internalOptions[i].checked) {
                    // emit the new checked value v-model bound to this group
                    this.$emit('update:modelValue', option.value);
                }
            });
        },
        focus () {
            this.$refs.inputs?.[0]?.focus();
        },
        blur () {
            for (const input of this.$refs.inputs) {
                input.blur();
            }
        }
    }
};

const _hoisted_1$8 = { class: "ff-radio-group" };
const _hoisted_2$4 = {
  key: 0,
  class: "ff-radio-group-label"
};

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ff_radio_button = vue.resolveComponent("ff-radio-button");

  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$8, [
    ($props.label)
      ? (vue.openBlock(), vue.createElementBlock("label", _hoisted_2$4, vue.toDisplayString($props.label), 1 /* TEXT */))
      : vue.createCommentVNode("v-if", true),
    vue.createElementVNode("div", {
      class: vue.normalizeClass(["ff-radio-group-options", 'ff-radio-group--' + $props.orientation]),
      style: vue.normalizeStyle($props.orientation === 'grid' ? {'grid-template-columns': `repeat(${$props.columns}, 1fr)`} : '')
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.internalOptions, (option) => {
        return (vue.openBlock(), vue.createBlock(_component_ff_radio_button, {
          key: option.label,
          ref_for: true,
          ref: "inputs",
          value: option.value,
          label: option.label,
          checked: option.checked,
          description: option.description,
          disabled: option.disabled,
          "hide-description": $props.orientation === 'horizontal',
          onSelect: $options.select
        }, null, 8 /* PROPS */, ["value", "label", "checked", "description", "disabled", "hide-description", "onSelect"]))
      }), 128 /* KEYED_FRAGMENT */))
    ], 6 /* CLASS, STYLE */)
  ]))
}

script$a.render = render$9;
script$a.__file = "src/components/form/RadioGroup.vue";

var script$9 = {
    name: 'ff-radio-button',
    props: {
        label: {
            required: true,
            type: String
        },
        value: {
            required: true,
            type: [String, Number]
        },
        checked: {
            default: false,
            type: Boolean
        },
        description: {
            default: null,
            type: String
        },
        disabled: {
            default: false,
            type: Boolean
        },
        hideDescription: {
            default: false,
            type: Boolean
        }
    },
    emits: ['select'],
    methods: {
        select: function (value) {
            if (!this.disabled) {
                this.$emit('select', value);
            }
        },
        focus () {
            this.$refs.input?.focus();
        },
        blur () {
            this.$refs.input?.blur();
        }
    }
};

const _hoisted_1$7 = ["disabled"];
const _hoisted_2$3 = ["value"];
const _hoisted_3$3 = ["checked"];
const _hoisted_4$2 = {
  key: 0,
  class: "ff-description"
};

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("label", {
    class: "ff-radio-btn",
    disabled: $props.disabled,
    onClick: _cache[1] || (_cache[1] = $event => ($options.select($props.value)))
  }, [
    vue.createElementVNode("input", {
      type: "radio",
      value: $props.value
    }, null, 8 /* PROPS */, _hoisted_2$3),
    vue.createElementVNode("span", {
      ref: "input",
      class: "checkbox",
      checked: $props.checked,
      tabindex: "0",
      onKeydown: _cache[0] || (_cache[0] = vue.withKeys(vue.withModifiers($event => ($options.select($props.value)), ["prevent"]), ["space"]))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, _hoisted_3$3),
    vue.createElementVNode("label", null, vue.toDisplayString($props.label), 1 /* TEXT */),
    ($props.description && !$props.hideDescription)
      ? (vue.openBlock(), vue.createElementBlock("p", _hoisted_4$2, vue.toDisplayString($props.description), 1 /* TEXT */))
      : vue.createCommentVNode("v-if", true)
  ], 8 /* PROPS */, _hoisted_1$7))
}

script$9.render = render$8;
script$9.__file = "src/components/form/RadioButton.vue";

var script$8 = {
    name: 'ff-tile-selection',
    props: {
        modelValue: {
            default: null,
            type: [String, Number]
        }
    },
    emits: ['update:modelValue'],
    data () {
        return {
            selected: null,
            children: []
        }
    },
    watch: {
        modelValue: function (value) {
            this.$nextTick(() => {
                this.checkState(value);
            });
        }
    },
    mounted () {
        this.$nextTick(() => {
            for (let i = 0; i < this.children.length; i++) {
                if (this.modelValue !== this.children[i].value) {
                    this.children[i].selected = false;
                } else {
                    this.children[i].selected = true;
                }
            }
        });
    },
    methods: {
        registerOption: function (child) {
            this.children.push(child);
            this.checkState(this.modelValue);
        },
        setSelected (selected) {
            if (selected?.value === this.modelValue) {
                this.$emit('update:modelValue', null);
            } else {
                this.$emit('update:modelValue', selected.value);
            }
        },
        checkState (value) {
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].selected = value === this.children[i].value;
            }
        },
        focus () {
            this.children?.[0].focus();
        },
        blur () {
            for (const child of this.children) {
                child.blur();
            }
        }
    }
};

const _hoisted_1$6 = {
  ref: "options",
  class: "ff-tile-selection"
};

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$6, [
    vue.renderSlot(_ctx.$slots, "default")
  ], 512 /* NEED_PATCH */))
}

script$8.render = render$7;
script$8.__file = "src/components/form/TileSelection.vue";

var script$7 = {
    name: 'ff-tile-selection-option',
    components: {
        CheckCircleIcon: solid.CheckCircleIcon,
        PencilAltIcon: solid.PencilAltIcon
    },
    props: {
        value: {
            required: true,
            type: [String, Number]
        },
        editable: {
            default: false,
            type: Boolean
        },
        disabled: {
            default: false,
            type: Boolean
        },
        label: {
            default: '',
            type: String
        },
        description: {
            default: '',
            type: String
        },
        price: {
            default: '',
            type: String
        },
        priceInterval: {
            default: '',
            type: String
        },
        meta: {
            default: null,
            type: Array
        }
    },
    emits: ['edit'],
    data () {
        return {
            selected: false
        }
    },
    mounted () {
        this.$parent.registerOption(this);
    },
    methods: {
        select (allowEdit = false) {
            if (this.disabled) {
                return
            }

            if (!this.editable) {
                this.$parent.setSelected({
                    value: this.value,
                    label: this.label,
                    description: this.description,
                    price: this.price
                });
                this.selected = !this.selected;
            } else if (allowEdit) {
                this.$emit('edit');
            }
        },
        focus () {
            this.$refs.input?.focus();
        },
        blur () {
            this.$refs.input?.blur();
        }
    }
};

const _hoisted_1$5 = { class: "ff-tile-selection-option--header" };
const _hoisted_2$2 = { class: "ff-tile-selection-option--price" };
const _hoisted_3$2 = {
  key: 0,
  class: "ff-tile-selection-option--description"
};
const _hoisted_4$1 = {
  key: 1,
  class: "ff-tile-selection-option--meta"
};

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PencilAltIcon = vue.resolveComponent("PencilAltIcon");
  const _component_CheckCircleIcon = vue.resolveComponent("CheckCircleIcon");
  const _component_ff_markdown_viewer = vue.resolveComponent("ff-markdown-viewer");

  return (vue.openBlock(), vue.createElementBlock("div", {
    ref: "input",
    class: vue.normalizeClass(["ff-tile-selection-option", {'editable': $props.editable, 'disabled': $props.disabled, 'active': $data.selected}]),
    tabindex: "0",
    onClick: _cache[1] || (_cache[1] = $event => ($options.select(false))),
    onKeydown: _cache[2] || (_cache[2] = vue.withKeys(vue.withModifiers($event => ($options.select(true)), ["prevent"]), ["space"]))
  }, [
    vue.createElementVNode("div", _hoisted_1$5, [
      vue.createElementVNode("h2", null, [
        ($props.editable)
          ? (vue.openBlock(), vue.createBlock(_component_PencilAltIcon, {
              key: 0,
              class: "ff-tile-selection-option--edit",
              onClick: _cache[0] || (_cache[0] = $event => ($options.select(true)))
            }))
          : (vue.openBlock(), vue.createBlock(_component_CheckCircleIcon, { key: 1 })),
        vue.createTextVNode(" " + vue.toDisplayString($props.label), 1 /* TEXT */)
      ]),
      vue.createElementVNode("div", _hoisted_2$2, [
        vue.createElementVNode("h2", null, vue.toDisplayString($props.price), 1 /* TEXT */),
        vue.createElementVNode("label", null, vue.toDisplayString($props.priceInterval), 1 /* TEXT */)
      ])
    ]),
    ($props.description)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2, [
          vue.createVNode(_component_ff_markdown_viewer, { content: $props.description }, null, 8 /* PROPS */, ["content"])
        ]))
      : vue.createCommentVNode("v-if", true),
    ($props.meta)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$1, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($props.meta, (row, $index) => {
            return (vue.openBlock(), vue.createElementBlock("div", { key: $index }, [
              vue.createElementVNode("span", null, vue.toDisplayString(row.key), 1 /* TEXT */),
              vue.createElementVNode("span", null, vue.toDisplayString(row.value), 1 /* TEXT */)
            ]))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$7.render = render$6;
script$7.__file = "src/components/form/TileSelectionOption.vue";

var script$6 = {
    name: 'ff-notification-pill',
    props: {
        count: {
            default: null,
            type: Number
        }
    }
};

const _hoisted_1$4 = { class: "ff-notification-pill" };

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$4, vue.toDisplayString($props.count), 1 /* TEXT */))
}

script$6.render = render$5;
script$6.__file = "src/components/NotificationPill.vue";

var script$5 = {
    name: 'ff-notification-toast',
    components: {
        XIcon: solid.XIcon
    },
    props: {
        message: {
            default: null,
            type: String
        },
        type: {
            default: 'info',
            type: String
        },
        countdown: {
            default: null,
            type: Number
        },
        showClose: {
            default: true,
            type: Boolean
        }
    },
    emits: ['close'],
    computed: {
        showActions: function () {
            return this.$slots.actions
        }
    },
    mounted () {
        if (this.countdown) {
            // if a countdown is set, emit the "close" event after the countdown timer expires
            setTimeout(() => {
                this.close();
            }, this.countdown);
        }
    },
    methods: {
        close: function () {
            this.$emit('close');
        }
    }
};

const _hoisted_1$3 = { class: "ff-notification-toast--message" };
const _hoisted_2$1 = /*#__PURE__*/vue.createElementVNode("span", { class: "ff-notification-toast--bar" }, null, -1 /* HOISTED */);
const _hoisted_3$1 = { class: "ff-notification-toast--close" };
const _hoisted_4 = {
  key: 1,
  class: "countdown-wrapper"
};
const _hoisted_5 = {
  key: 0,
  class: "ff-notification-toast--actions"
};

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_XIcon = vue.resolveComponent("XIcon");

  return (vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(["ff-notification-toast", 'ff-notification-toast--' + $props.type])
  }, [
    vue.createElementVNode("div", _hoisted_1$3, [
      vue.createElementVNode("div", null, [
        _hoisted_2$1,
        vue.renderSlot(_ctx.$slots, "message", {}, () => [
          vue.createTextVNode(vue.toDisplayString($props.message), 1 /* TEXT */)
        ])
      ]),
      vue.createElementVNode("span", _hoisted_3$1, [
        ($props.showClose)
          ? (vue.openBlock(), vue.createBlock(_component_XIcon, {
              key: 0,
              onClick: _cache[0] || (_cache[0] = $event => ($options.close()))
            }))
          : vue.createCommentVNode("v-if", true),
        ($props.countdown)
          ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4, [
              vue.createElementVNode("div", {
                class: "countdown-pie countdown-spinner",
                style: vue.normalizeStyle('animation: rota ' + ($props.countdown/1000) + 's linear infinite;')
              }, null, 4 /* STYLE */),
              vue.createElementVNode("div", {
                class: "countdown-pie countdown-filler",
                style: vue.normalizeStyle('animation: fill ' + ($props.countdown/1000) + 's steps(1, end) infinite;')
              }, null, 4 /* STYLE */),
              vue.createElementVNode("div", {
                class: "countdown-mask",
                style: vue.normalizeStyle('animation: mask ' + ($props.countdown/1000) + 's steps(1, end) infinite;')
              }, null, 4 /* STYLE */)
            ]))
          : vue.createCommentVNode("v-if", true)
      ])
    ]),
    ($options.showActions)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_5, [
          vue.renderSlot(_ctx.$slots, "actions")
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 2 /* CLASS */))
}

script$5.render = render$4;
script$5.__file = "src/components/NotificationToast.vue";

var script$4 = {
    name: 'ff-tabs',
    props: {
        orientation: {
            default: '',
            type: String
        }
    },
    emits: ['tab-selected'],
    data () {
        return {
            tabs: [],
            active: -1
        }
    },
    created () {
        this.tabs = this.$slots.default().map((vnode) => {
            return vnode.props
        });
    },
    mounted () {
        this.selectTab(0);
    },
    methods: {
        selectTab (i) {
            this.selectedIndex = i;

            // loop over all the tabs
            this.tabs.forEach((tab, index) => {
                tab.isActive = (index === i);
                if (tab.isActive) {
                    this.$emit('tab-selected', tab);
                }
            });
        }
    }
};

const _hoisted_1$2 = { ref: "ff-tabs" };
const _hoisted_2 = ["onClick"];
const _hoisted_3 = { class: "ff-tabs-content" };

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2, [
    vue.createElementVNode("ul", {
      class: vue.normalizeClass(["ff-tabs", 'ff-tabs--' + $props.orientation])
    }, [
      (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList($data.tabs, (tab, $index) => {
        return (vue.openBlock(), vue.createElementBlock("li", {
          key: tab.label,
          class: vue.normalizeClass(["ff-tab-option transition-fade--color", {'ff-tab-option--active': tab.isActive}]),
          onClick: $event => ($options.selectTab($index))
        }, vue.toDisplayString(tab.label), 11 /* TEXT, CLASS, PROPS */, _hoisted_2))
      }), 128 /* KEYED_FRAGMENT */))
    ], 2 /* CLASS */),
    vue.createElementVNode("div", _hoisted_3, [
      vue.renderSlot(_ctx.$slots, "default")
    ])
  ], 512 /* NEED_PATCH */))
}

script$4.render = render$3;
script$4.__file = "src/components/tabs/Tabs.vue";

var script$3 = {
    name: 'ff-tab',
    props: {
        label: {
            default: 'Tab',
            type: String
        },
        to: {
            default: '',
            type: String
        }
    },
    render: () => {
        return null
    }
};

script$3.__file = "src/components/tabs/Tab.vue";

var script$2 = {
    name: 'ff-check',
    components: {
        CheckIcon: outline.CheckIcon
    },
    props: {
        value: {
            default: false,
            type: Boolean
        }
    }
};

const _hoisted_1$1 = { class: "ff-icon ff-icon-lg" };

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CheckIcon = vue.resolveComponent("CheckIcon");

  return (vue.openBlock(), vue.createElementBlock("i", _hoisted_1$1, [
    ($props.value)
      ? (vue.openBlock(), vue.createBlock(_component_CheckIcon, {
          key: 0,
          class: "ff-icon ff-icon-lg"
        }))
      : vue.createCommentVNode("v-if", true)
  ]))
}

script$2.render = render$2;
script$2.__file = "src/components/Check.vue";

var script$1 = {
    name: 'ff-list-item',
    props: {
        icon: {
            type: Function,
            default: null
        },
        label: {
            type: String,
            default: ''
        },
        kind: {
            type: String,
            default: ''
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    computed: {
        className () {
            return 'ff-list-item--' + this.kind
        }
    }
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("li", {
    class: vue.normalizeClass(["ff-list-item", [$options.className, $props.disabled ? 'disabled' : ''] ])
  }, [
    (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent($props.icon))),
    vue.createElementVNode("label", null, vue.toDisplayString($props.label), 1 /* TEXT */)
  ], 2 /* CLASS */))
}

script$1.render = render$1;
script$1.__file = "src/components/ListItem.vue";

var script = {
    name: 'ff-markdown-viewer',
    props: {
        content: {
            required: true,
            type: String
        }
    },
    computed: {
        markdownToHtml () {
            return this.md(this.content)
        }
    }
};

const _hoisted_1 = ["innerHTML"];

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
    vue.createCommentVNode(" eslint-disable-next-line vue/no-v-html "),
    vue.createElementVNode("div", { innerHTML: $options.markdownToHtml }, null, 8 /* PROPS */, _hoisted_1)
  ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))
}

script.render = render;
script.__file = "src/components/Markdown.vue";

var components = {
    FFButton: script$l,
    FFKebabMenu: script$k,
    FFDialogBox: script$g,
    FFHelpTooltip: script$f,
    FFListItem: script$1,
    FFCheck: script$2,
    FFMarkdownViewer: script,
    // Data Table
    FFDataTable: script$j,
    FFDataTableRow: script$i,
    FFDataTableCell: script$h,
    // Form Elements
    FFTextInput: script$e,
    FFDropdown: script$d,
    FFDropdownOption: script$c,
    FFCheckbox: script$b,
    FFRadioGroup: script$a,
    FFRadioButton: script$9,
    FFTileSelection: script$8,
    FFTileSelectionOption: script$7,
    // Notifications
    FFNotificationPill: script$6,
    FFNotificationToast: script$5,
    // Tabs
    FFTabs: script$4,
    FFTab: script$3
};

/* eslint-disable no-prototype-builtins */


const markedMixin = {
    methods: {
        md: function (content) {
            return marked.marked.parse(content)
        }
    }
};

const plugin = {
    install (Vue) {
        // third-party
        Vue.mixin(markedMixin);
        // Our Components & Directives
        for (const prop in components) {
            if (components.hasOwnProperty(prop)) {
                const component = components[prop];
                Vue.component(component.name, component);
            }
        }
        for (const prop in directives) {
            if (directives.hasOwnProperty(prop)) {
                const directive = directives[prop];
                Vue.directive(directive.name, directive);
            }
        }
    }
};

module.exports = plugin;
